<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>질문 게시판</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f8fafc;
        }

        .card {
            transition: all 0.3s ease;
        }

        .highlight {
            animation: highlight 2s ease;
        }

        @keyframes highlight {
            0% { background-color: rgba(147, 197, 253, 0.5); }
            100% { background-color: white; }
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            border-radius: 4px;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.3s, fadeOut 0.5s 2.5s;
            animation-fill-mode: forwards;
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; visibility: hidden; }
        }
        
        .modal-enter {
            animation: modalEnter 0.3s ease forwards;
        }
        
        @keyframes modalEnter {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .refresh-spin {
            animation: refreshSpin 1s linear;
        }
        
        @keyframes refreshSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .heart-button {
            transition: transform 0.2s ease;
        }
        
        .heart-button:hover {
            transform: scale(1.1);
        }
        
        .heart-button:active {
            transform: scale(0.9);
        }
        
        .heart-animation {
            animation: heartBeat 0.5s ease-in-out;
        }
        
        @keyframes heartBeat {
            0% { transform: scale(1); }
            25% { transform: scale(1.2); }
            50% { transform: scale(0.95); }
            75% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .link-preview {
            border-left: 4px solid #e2e8f0;
            transition: all 0.2s ease;
        }
        
        .link-preview:hover {
            border-left-color: #3b82f6;
            background-color: #f8fafc;
        }
        
        .copyright {
            font-size: 0.85rem;
            color: #6b7280;
            display: inline-flex;
            align-items: center;
            margin-left: 12px;
        }

        /* ----- Wall View CSS ----- */
        .layout-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* 최소 280px, 가능한 만큼 칼럼 */
            gap: 16px; /* 카드 간 간격 */
            align-items: start; /* 상단 정렬 */
            overflow-y: auto; /* Ensure vertical scrolling within the grid */
            height: 100%; /* Take full height of parent (max-h-[70vh]) */
        }

        /* ----- Timeline View CSS ----- */
        .layout-timeline {
            display: flex;
            overflow-x: auto; /* Horizontal scrolling */
            overflow-y: hidden; /* No vertical scrolling */
            gap: 16px;
            padding-bottom: 16px; /* Space for horizontal scrollbar */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            align-items: flex-start; /* Align cards to the top in the timeline */
            height: 100%; /* Take full height of parent (max-h-[70vh]) */
        }

        .layout-timeline .card {
            flex-shrink: 0; /* Prevent cards from shrinking */
            width: 300px; /* Fixed width for timeline cards */
            max-width: 90vw; /* Responsive for smaller screens */
            height: auto; /* Allow height to adjust based on content */
        }

        /* Scrollbar styling for horizontal timeline view */
        .layout-timeline::-webkit-scrollbar {
            height: 8px; /* Height for horizontal scrollbar */
        }
        .layout-timeline::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .layout-timeline::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .layout-timeline::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Global scrollbar styling for posts-container (applies to list and grid vertical scroll) */
        #posts-container::-webkit-scrollbar {
            width: 8px; /* Vertical scrollbar width */
        }
        #posts-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #posts-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #posts-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-5 rounded-lg flex flex-col items-center">
            <div class="loader mb-3"></div>
            <p class="text-gray-700">처리 중입니다...</p>
        </div>
    </div>

    <div id="toast-container"></div>

    <!-- Admin Modal - Only for Data Reset -->
    <div id="admin-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md modal-enter">
            <h3 class="text-xl font-bold mb-4 text-gray-800">관리자 인증</h3>
            <div id="admin-password-container">
                <label for="admin-password" class="block text-sm font-medium text-gray-700 mb-2">비밀번호를 입력하세요</label>
                <input type="password" id="admin-password" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
                <div class="flex justify-end space-x-3">
                    <button id="cancel-admin" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition">취소</button>
                    <button id="verify-admin" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition">확인</button>
                </div>
            </div>
            <div id="admin-controls" class="hidden">
                <p class="mb-4 text-gray-700">관리자 인증이 완료되었습니다.</p>
                <div class="flex justify-between">
                    <button id="reset-data" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition">모든 데이터 초기화</button>
                    <button id="close-admin" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition">닫기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- View Mode Selector Modal - Updated to open directly -->
    <div id="view-mode-selector-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md modal-enter">
            <h3 class="text-xl font-bold mb-4 text-gray-800">보기 방식 선택</h3>
            <div class="mb-4">
                <div class="flex items-center mb-2">
                    <input type="radio" id="radio-list-view" name="view-option" value="list" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 mr-2">
                    <label for="radio-list-view" class="text-gray-700">목록형 (기존 스크롤 방식)</label>
                </div>
                <div class="flex items-center mb-2">
                    <input type="radio" id="radio-wall-view" name="view-option" value="wall" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 mr-2">
                    <label for="radio-wall-view" class="text-gray-700">담벼락형 (카드 그리드 방식)</label>
                </div>
                <div class="flex items-center">
                    <input type="radio" id="radio-timeline-view" name="view-option" value="timeline" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 mr-2">
                    <label for="radio-timeline-view" class="text-gray-700">타임라인형 (가로 스크롤 방식)</label>
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="close-view-mode-selector" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition">취소</button>
                <button id="save-view-mode" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition">저장</button>
            </div>
        </div>
    </div>

    <!-- Submission Modal - Existing -->
    <div id="submission-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md modal-enter">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">새 질문 등록</h3>
                <button id="close-submission" class="text-gray-500 hover:text-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <form id="submission-form" action="YOUR_GOOGLE_APP_SCRIPT_URL_HERE" method="POST">
                <input type="hidden" name="action" value="submit">
                <div class="mb-4">
                    <label for="name" class="block text-sm font-medium text-gray-700 mb-1">이름 *</label>
                    <input type="text" id="name" name="name" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="mb-4">
                    <label for="question" class="block text-sm font-medium text-gray-700 mb-1">질문 또는 메시지 *</label>
                    <textarea id="question" name="question" rows="4" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"></textarea>
                </div>
                <div class="mb-6">
                    <label for="url" class="block text-sm font-medium text-gray-700 mb-1">관련 URL (선택사항)</label>
                    <input type="text" id="url" name="url" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="https://">
                </div>
                <button type="submit" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition flex items-center justify-center">
                    <span>제출하기</span>
                </button>
            </form>
        </div>
    </div>

    <!-- Debug Modal - Existing -->
    <div id="debug-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-4xl modal-enter">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">디버그 정보</h3>
                <button id="close-debug" class="text-gray-500 hover:text-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="overflow-auto max-h-[70vh]">
                <div class="mb-4">
                    <h4 class="font-medium text-gray-700 mb-2">마지막 응답 데이터:</h4>
                    <pre id="debug-response" class="bg-gray-100 p-3 rounded-md text-sm overflow-auto max-h-40"></pre>
                </div>
                <div class="mb-4">
                    <h4 class="font-medium text-gray-700 mb-2">로컬 저장 데이터:</h4>
                    <pre id="debug-local" class="bg-gray-100 p-3 rounded-md text-sm overflow-auto max-h-40"></pre>
                </div>
                <div>
                    <h4 class="font-medium text-gray-700 mb-2">로그:</h4>
                    <div id="debug-log" class="bg-gray-100 p-3 rounded-md text-sm overflow-auto max-h-40"></div>
                </div>
            </div>
            <div class="mt-4 flex justify-end">
                <button id="clear-debug-log" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition mr-2">로그 지우기</button>
                <button id="close-debug-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition">닫기</button>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <header class="mb-8">
            <div class="flex justify-between items-center mb-6">
                <div class="flex items-center">
                    <h1 class="text-3xl font-bold text-gray-800">질문 게시판</h1>
                    <span class="copyright">ⓒ 2025. Jeongyeon</span>
                </div>
                <div class="flex items-center space-x-3">
                    <span id="current-date" class="text-sm bg-gray-100 text-gray-700 py-1 px-3 rounded-full"></span>
                    <button id="debug-btn" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition text-sm hidden">디버그</button>
                    <!-- 보기 방식 변경 버튼 -->
                    <button id="view-mode-btn" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition text-sm">보기 방식 변경</button>
                    <!-- 관리자 버튼 -->
                    <button id="admin-btn" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition text-sm">관리자</button>
                </div>
            </div>
            <div class="h-1 w-full bg-gradient-to-r from-blue-400 to-green-400 rounded-full"></div>
        </header>

        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold text-gray-800">질문 목록</h2>
                <div class="flex items-center space-x-3">
                    <span id="post-count" class="text-sm bg-blue-100 text-blue-800 py-1 px-3 rounded-full">총 0개</span>
                    <button id="refresh-btn" class="p-2 bg-gray-100 rounded-full hover:bg-gray-200 transition" title="새로고침">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" id="refresh-icon">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                    </button>
                    <button id="add-question-btn" class="p-2 bg-blue-500 rounded-full hover:bg-blue-600 transition" title="새 질문 등록">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                        </svg>
                    </button>
                </div>
            </div>
            <!-- posts-container는 max-h와 overflow-y-auto를 기본으로 가짐. 레이아웃은 JS가 클래스 추가/제거로 제어 -->
            <div id="posts-container" class="max-h-[70vh] overflow-y-auto">
                <div class="flex items-center justify-center py-12 text-gray-500">
                    <div class="loader mr-3"></div>
                    <p>질문을 불러오는 중입니다...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Submission Success Modal - Existing -->
    <div id="submission-success" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-40 hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md modal-enter">
            <div class="flex flex-col items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-green-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
                <h3 class="text-xl font-bold mb-2 text-gray-800">질문이 등록되었습니다!</h3>
                <p class="text-gray-600 text-center mb-6">질문이 성공적으로 등록되었습니다. 목록에서 확인하실 수 있습니다.</p>
                <button id="back-to-list" class="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition">목록으로 돌아가기</button>
            </div>
        </div>
    </div>

    <script>
        // 웹앱 URL 설정
        // IMPORTANT: Replace this with your actual Google Apps Script Web App URL
        const webAppUrl = 'https://script.google.com/macros/s/AKfycbz_S2EJmTdVCsM7Ugaos8HthVBkmo56EgBtY0bGhsHUH55_aFPuvxE1rkEfM4tnwKRY/exec'; // 여기에 여러분의 구글 앱스 스크립트 웹 앱 URL을 붙여넣으세요!

        // 디버그 모드 설정
        const DEBUG_MODE = true;
        
        // 디버그 로그 배열
        let debugLogs = [];
        let lastResponseData = null;
        
        // 관리자 로그인 상태 (데이터 삭제 권한에만 사용)
        let isAdminLoggedIn = false; 

        // 보기 방식 상태 (기본값: list) - 이제 서버에서 받아올 것임
        let currentViewMode = 'list'; // 초기값은 'list'로 설정하고, fetchPosts에서 서버 값을 받아 업데이트

        // DOM 요소
        const submissionForm = document.getElementById('submission-form');
        const submissionModal = document.getElementById('submission-modal');
        const submissionSuccess = document.getElementById('submission-success'); 
        const addQuestionBtn = document.getElementById('add-question-btn');
        const closeSubmissionBtn = document.getElementById('close-submission');
        const postsContainer = document.getElementById('posts-container');
        const postCount = document.getElementById('post-count');
        const refreshBtn = document.getElementById('refresh-btn');
        const refreshIcon = document.getElementById('refresh-icon');
        const adminBtn = document.getElementById('admin-btn');
        const adminModal = document.getElementById('admin-modal');
        const adminPasswordContainer = document.getElementById('admin-password-container');
        const adminControls = document.getElementById('admin-controls');
        const adminPassword = document.getElementById('admin-password');
        const verifyAdminBtn = document.getElementById('verify-admin');
        const cancelAdminBtn = document.getElementById('cancel-admin');
        const resetDataBtn = document.getElementById('reset-data');
        const closeAdminBtn = document.getElementById('close-admin');
        const loadingOverlay = document.getElementById('loading-overlay');
        const toastContainer = document.getElementById('toast-container');
        const currentDateElement = document.getElementById('current-date');
        const debugBtn = document.getElementById('debug-btn'); 
        const debugModal = document.getElementById('debug-modal');
        const closeDebugBtn = document.getElementById('close-debug');
        const closeDebugBtnBottom = document.getElementById('close-debug-btn');
        const clearDebugLogBtn = document.getElementById('clear-debug-log');
        const debugResponseEl = document.getElementById('debug-response');
        const debugLocalEl = document.getElementById('debug-local');
        const debugLogEl = document.getElementById('debug-log');

        // 보기 방식 관련 새 DOM 요소 (비밀번호 모달은 제거)
        const viewModeBtn = document.getElementById('view-mode-btn');
        const viewModeSelectorModal = document.getElementById('view-mode-selector-modal');
        const radioListView = document.getElementById('radio-list-view');
        const radioWallView = document.getElementById('radio-wall-view');
        const radioTimelineView = document.getElementById('radio-timeline-view'); // 새 타임라인 라디오 버튼
        const saveViewModeBtn = document.getElementById('save-view-mode');
        const closeViewModeSelectorBtn = document.getElementById('close-view-mode-selector');

        // 디버그 로그 함수
        function logDebug(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                message: typeof message === 'object' ? JSON.stringify(message) : message,
                type
            };
            
            debugLogs.push(logEntry);
            
            if (debugLogEl) {
                const logItem = document.createElement('div');
                logItem.className = `mb-1 ${type === 'error' ? 'text-red-600' : type === 'success' ? 'text-green-600' : 'text-gray-700'}`;
                logItem.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${logEntry.message}`;
                debugLogEl.appendChild(logItem);
                debugLogEl.scrollTop = debugLogEl.scrollHeight;
            }
            
            if (type === 'error') {
                console.error(`[${timestamp}] ${message}`);
            } else {
                console.log(`[${timestamp}] ${message}`);
            }
        }

        // 디버그 정보 업데이트
        function updateDebugInfo() {
            if (lastResponseData) {
                debugResponseEl.textContent = JSON.stringify(lastResponseData, null, 2);
            } else {
                debugResponseEl.textContent = '아직 응답 데이터가 없습니다.';
            }
            
            debugLocalEl.textContent = JSON.stringify({
                likedPosts,
                currentViewMode, // 보기 방식 추가
                localStorage: { ...localStorage }
            }, null, 2);
        }

        // 좋아요 상태 관리
        let likedPosts = {};
        
        // 로컬 스토리지에서 좋아요 상태 불러오기
        function loadLikedPosts() {
            const saved = localStorage.getItem('likedPosts');
            if (saved) {
                try {
                    likedPosts = JSON.parse(saved);
                    logDebug('좋아요 상태를 로컬 스토리지에서 불러왔습니다.');
                } catch (e) {
                    likedPosts = {};
                    logDebug('좋아요 상태 파싱 중 오류가 발생했습니다: ' + e.message, 'error');
                }
            }
        }
        
        // 좋아요 상태 저장
        function saveLikedPosts() {
            localStorage.setItem('likedPosts', JSON.stringify(likedPosts));
            logDebug('좋아요 상태를 로컬 스토리지에 저장했습니다.');
        }

        // 현재 날짜 표시
        function displayCurrentDate() {
            const now = new Date();
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric', 
                weekday: 'short'
            };
            const formatter = new Intl.DateTimeFormat('ko-KR', options);
            currentDateElement.textContent = formatter.format(now);
        }

        // 토스트 메시지 표시 함수
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} text-white`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            
            logDebug(`토스트 메시지 표시: ${message} (${type})`);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // 로딩 오버레이 표시/숨김 함수
        function toggleLoading(show) {
            loadingOverlay.classList.toggle('hidden', !show);
            logDebug(`로딩 오버레이: ${show ? '표시' : '숨김'}`);
        }

        // 새로고침 아이콘 애니메이션
        function animateRefreshIcon() {
            refreshIcon.classList.add('refresh-spin');
            // 애니메이션이 끝나면 클래스 제거
            refreshIcon.addEventListener('animationend', () => {
                refreshIcon.classList.remove('refresh-spin');
            }, { once: true });
        }

        // 보기 방식 적용 함수 (이제 서버에서 받아온 currentViewMode 사용)
        function applyViewMode() {
            // 모든 레이아웃 관련 클래스 제거
            postsContainer.classList.remove('space-y-4', 'layout-grid', 'layout-timeline');

            // overflow 속성 초기화
            postsContainer.style.overflowX = 'hidden';
            postsContainer.style.overflowY = 'auto'; // 기본적으로 세로 스크롤 허용

            if (currentViewMode === 'wall') {
                postsContainer.classList.add('layout-grid');
            } else if (currentViewMode === 'timeline') {
                postsContainer.classList.add('layout-timeline');
                postsContainer.style.overflowX = 'auto'; // 타임라인은 가로 스크롤
                postsContainer.style.overflowY = 'hidden'; // 세로 스크롤 비활성화
            } else { // 'list'
                postsContainer.classList.add('space-y-4');
            }
            logDebug(`보기 방식 적용: ${currentViewMode}`);
        }

        // 보기 방식을 서버에 업데이트하는 함수
        async function updateGlobalViewMode(newMode) {
            logDebug(`전역 보기 방식 업데이트 요청: ${newMode}`);
            toggleLoading(true);

            try {
                const formData = new URLSearchParams();
                formData.append('action', 'updateViewMode');
                formData.append('newMode', newMode);

                const response = await fetch(webAppUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP 오류! 상태: ${response.status}, 메시지: ${errorText}`);
                }

                const data = await response.json();

                if (data.status === 'success') {
                    logDebug('전역 보기 방식 서버 업데이트 성공', 'success');
                    currentViewMode = newMode; // 로컬 상태 업데이트
                    applyViewMode(); // UI에 적용
                    showToast(`보기 방식이 ${newMode === 'list' ? '목록형' : (newMode === 'wall' ? '담벼락형' : '타임라인형')}으로 변경되었습니다.`, 'success');
                    viewModeSelectorModal.classList.add('hidden'); // 모달 닫기
                    fetchPosts(false); // 변경된 뷰 모드로 게시물 목록 새로고침 (모든 사용자에게 적용되도록)
                } else {
                    logDebug(`전역 보기 방식 서버 업데이트 실패: ${data.message}`, 'error');
                    showToast(`보기 방식 변경 실패: ${data.message}`, 'error');
                }
            } catch (error) {
                logDebug(`전역 보기 방식 업데이트 중 오류 발생: ${error.message}`, 'error');
                showToast('보기 방식 업데이트 중 네트워크 오류가 발생했습니다. ' + error.message, 'error');
            } finally {
                toggleLoading(false);
            }
        }

        // 데이터 가져오기 함수 (이제 서버에서 globalViewMode를 받아옴)
        async function fetchPosts(showLoading = false, isInitialLoad = false) { 
            try {
                if (showLoading) {
                    postsContainer.innerHTML = `
                        <div class="flex items-center justify-center py-12 text-gray-500">
                            <div class="loader mr-3"></div>
                            <p>질문을 불러오는 중입니다...</p>
                        </div>
                    `;
                    toggleLoading(true);
                } else {
                    animateRefreshIcon(); // 새로고침 아이콘 애니메이션
                }
                
                logDebug('데이터 가져오기 시작...');
                
                const timestamp = new Date().getTime();
                const url = `${webAppUrl}?t=${timestamp}`; // 캐시 방지
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP 오류! 상태: ${response.status}, 메시지: ${errorText}`);
                }

                const rawData = await response.json();

                lastResponseData = rawData; 
                logDebug('서버 응답 데이터:', 'info');
                logDebug(rawData);
                
                if (Array.isArray(rawData.posts)) { // 응답 구조 변경: { posts: [...], globalViewMode: "..." }
                    currentViewMode = rawData.globalViewMode || 'list'; // 서버에서 받아온 보기 방식 적용
                    applyViewMode(); // UI에 보기 방식 적용 (fetchPosts에서 한 번만 호출)
                    
                    const postsToRender = rawData.posts.map((post, index) => {
                        return {
                            ...post,
                            Likes: post.Likes || 0,
                            rowIndex: post.rowIndex // Google Apps Script에서 rowIndex를 받아옴
                        };
                    });
                    
                    logDebug(`${postsToRender.length}개의 게시물을 가져왔습니다. (현재 보기 방식: ${currentViewMode})`, 'success');
                    renderPosts(postsToRender);
                    postCount.textContent = `총 ${postsToRender.length}개`;
                } else {
                    logDebug('유효한 게시물 데이터가 없습니다 (배열 아님).', 'error');
                    renderPosts([]); // 데이터 형식이 잘못되면 빈 배열로 렌더링
                    postCount.textContent = '총 0개';
                }
                
            } catch (error) {
                logDebug(`데이터를 가져오는 중 오류가 발생했습니다: ${error.message}`, 'error');
                if (!isInitialLoad) { 
                    showToast('데이터를 불러오는 중 오류가 발생했습니다. ' + error.message, 'error');
                } else { 
                    postsContainer.innerHTML = `
                        <div class="flex items-center justify-center py-8 text-red-500">
                            <p>데이터를 불러오지 못했습니다. 웹 앱 URL 설정 및 배포 상태를 확인해주세요.<br/>(${error.message})</p>
                        </div>
                    `;
                }
                renderPosts([]); 
                postCount.textContent = '총 0개';
            } finally {
                if (showLoading) {
                    toggleLoading(false);
                }
                updateDebugInfo();
            }
        }

        // 게시물 렌더링 함수
        function renderPosts(posts) {
            if (posts.length === 0) {
                postsContainer.innerHTML = `
                    <div class="flex items-center justify-center py-8 text-gray-500">
                        <p>아직 등록된 질문이 없습니다.</p>
                    </div>
                `;
                return;
            }

            postsContainer.innerHTML = '';
            
            // applyViewMode()는 fetchPosts에서 이미 호출됨
            // renderPosts는 실제 DOM을 업데이트하는 역할만 수행

            posts.forEach((post, index) => {
                const postId = post.id || `post-${post.rowIndex || index}`; 
                const card = document.createElement('div');
                card.className = 'card bg-white border border-gray-200 rounded-lg p-4 shadow-sm fade-in';
                card.setAttribute('data-id', postId);
                
                let linkPreviewHtml = '';
                if (post.url) {
                    try {
                        const url = new URL(post.url);
                        const domain = url.hostname;
                        
                        if (post.linkPreview && post.linkPreview.title) {
                            linkPreviewHtml = `
                                <div class="mt-3 mb-2">
                                    <a href="${post.url}" target="_blank" class="block link-preview p-3 rounded-md hover:no-underline">
                                        <div class="flex flex-col">
                                            <span class="text-sm text-blue-600 font-medium">${domain}</span>
                                            <span class="text-base font-medium text-gray-800 mt-1">${post.linkPreview.title}</span>
                                            <p class="text-sm text-gray-600 mt-1">${post.linkPreview.description || ''}</p>
                                        </div>
                                    </a>
                                </div>
                            `;
                        } else {
                            linkPreviewHtml = `
                                <div class="mt-2">
                                    <a href="${post.url}" target="_blank" class="text-blue-600 hover:underline text-sm flex items-center">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                                        </svg>
                                        ${domain}
                                    </a>
                                </div>
                            `;
                        }
                    } catch (e) {
                        linkPreviewHtml = '';
                        logDebug(`URL 파싱 오류 (${post.url}): ${e.message}`, 'error');
                    }
                }
                
                const isLiked = likedPosts[postId] === true;
                const likesCount = post.Likes || 0;
                
                let formattedDate = '날짜 정보 없음';
                try {
                    const date = post.timestamp ? new Date(post.timestamp) : new Date(); 
                    if (!isNaN(date.getTime())) {
                        formattedDate = `${date.getFullYear()}.${(date.getMonth()+1).toString().padStart(2, '0')}.${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                    } else {
                         logDebug(`유효하지 않은 timestamp: ${post.timestamp}`, 'error');
                    }
                } catch (e) {
                    logDebug(`날짜 포맷팅 오류: ${e.message}`, 'error');
                }
                
                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <h3 class="font-medium text-gray-800">${post.name || '익명'}</h3>
                        <span class="text-xs text-gray-500">${formattedDate}</span>
                    </div>
                    <p class="mt-2 text-gray-700 whitespace-pre-wrap">${post.question || '내용 없음'}</p>
                    ${linkPreviewHtml}
                    <div class="flex justify-end mt-3">
                        <div class="flex items-center space-x-2">
                            ${isAdminLoggedIn ? `
                                <button class="delete-button px-2 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200 transition text-xs" data-row-index="${post.rowIndex}">삭제</button>
                            ` : ''}
                            <button class="heart-button flex items-center space-x-1 text-sm text-gray-500 hover:text-red-500 transition" data-post-id="${postId}" data-row-index="${post.rowIndex}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ${isLiked ? 'text-red-500 fill-current' : ''}" viewBox="0 0 24 24" stroke="currentColor" stroke-width="${isLiked ? '0' : '2'}">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                                </svg>
                                <span>${likesCount}</span>
                            </button>
                        </div>
                    </div>
                `;
                
                postsContainer.appendChild(card);
                
                const heartButton = card.querySelector('.heart-button');
                heartButton.addEventListener('click', () => toggleLike(postId, heartButton));

                // 개별 삭제 버튼 이벤트 리스너 추가
                if (isAdminLoggedIn) {
                    const deleteButton = card.querySelector('.delete-button');
                    if (deleteButton) {
                        deleteButton.addEventListener('click', () => deletePost(parseInt(deleteButton.dataset.rowIndex)));
                    }
                }
            });
        }
        
        // Toggle like function
        function toggleLike(postId, button) {
            const isLiked = likedPosts[postId] === true;
            likedPosts[postId] = !isLiked;
            saveLikedPosts();
            
            const countSpan = button.querySelector('span');
            let count = parseInt(countSpan.textContent);
            
            if (isLiked) { 
                count = Math.max(0, count - 1);
            } else { 
                count += 1;
                button.classList.add('heart-animation');
                setTimeout(() => {
                    button.classList.remove('heart-animation');
                }, 500);
            }
            
            countSpan.textContent = count;
            
            const heartIcon = button.querySelector('svg');
            if (!isLiked) { 
                heartIcon.classList.add('text-red-500', 'fill-current');
                heartIcon.setAttribute('stroke-width', '0');
            } else { 
                heartIcon.classList.remove('text-red-500', 'fill-current');
                heartIcon.setAttribute('stroke-width', '2');
            }
            
            try {
                logDebug(`좋아요 상태 서버 업데이트 요청: postId=${postId}, 현재상태=${!isLiked}`);
                
                const submissionCard = button.closest('.card');
                const rowIndex = submissionCard.querySelector('.heart-button').dataset.rowIndex;

                if (!rowIndex) {
                    logDebug('오류: rowIndex를 찾을 수 없습니다. 좋아요 업데이트 실패.', 'error');
                    showToast('좋아요 처리 오류: 항목을 찾을 수 없습니다.', 'error');
                    return;
                }

                const formData = new URLSearchParams();
                formData.append('action', 'like');
                formData.append('rowIndex', rowIndex);

                fetch(webAppUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        logDebug('좋아요 서버 업데이트 성공. 새로운 좋아요 수: ' + data.newLikes, 'success');
                        countSpan.textContent = data.newLikes; 
                    } else {
                        logDebug(`좋아요 서버 업데이트 실패: ${data.message}`, 'error');
                        showToast(`좋아요 처리 실패: ${data.message}`, 'error');
                    }
                })
                .catch(e => {
                    logDebug(`좋아요 서버 업데이트 중 네트워크 오류 발생: ${e.message}`, 'error');
                    showToast('좋아요 처리 중 네트워크 오류가 발생했습니다.', 'error');
                });

            } catch (e) {
                logDebug(`좋아요 상태 서버 업데이트 요청 생성 중 오류 발생: ${e.message}`, 'error');
                showToast('좋아요 기능 오류가 발생했습니다.', 'error');
            }
        }

        // 개별 게시물 삭제 함수
        async function deletePost(rowIndex) {
            if (!confirm('정말로 이 게시물을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                return;
            }

            toggleLoading(true);
            logDebug(`게시물 삭제 요청 시작: rowIndex=${rowIndex}`);

            try {
                const formData = new URLSearchParams();
                formData.append('action', 'delete');
                formData.append('rowIndex', rowIndex);

                const response = await fetch(webAppUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP 오류! 상태: ${response.status}, 메시지: ${errorText}`);
                }

                const data = await response.json();

                if (data.status === 'success') {
                    logDebug(`게시물 (rowIndex: ${rowIndex}) 삭제 성공`, 'success');
                    showToast('게시물이 성공적으로 삭제되었습니다.', 'success');
                    fetchPosts(false); // 삭제 후 목록 새로고침
                } else {
                    logDebug(`게시물 삭제 실패: ${data.message}`, 'error');
                    showToast(`게시물 삭제 실패: ${data.message}`, 'error');
                }
            } catch (error) {
                logDebug(`게시물 삭제 중 오류 발생: ${error.message}`, 'error');
                showToast('게시물 삭제 중 네트워크 오류가 발생했습니다. ' + error.message, 'error');
            } finally {
                toggleLoading(false);
            }
        }

        // Form submission handling
        submissionForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const nameInput = document.getElementById('name');
            const questionInput = document.getElementById('question');
            const urlInput = document.getElementById('url');

            let urlValue = urlInput.value.trim();
            if (urlValue) {
                if (!urlValue.startsWith('http://') && !urlValue.startsWith('https://')) {
                    urlValue = 'https://' + urlValue;
                }
            }
            urlInput.value = urlValue; 

            if (!nameInput.value.trim()) {
                nameInput.focus();
                showToast('이름을 입력해주세요.', 'error');
                return;
            }
            
            if (!questionInput.value.trim()) {
                questionInput.focus();
                showToast('질문 또는 메시지를 입력해주세요.', 'error');
                return;
            }
            
            toggleLoading(true);
            
            logDebug('질문 제출 시작...');
            
            const formData = new FormData(submissionForm);
            
            fetch(webAppUrl, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => { throw new Error(text); });
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    logDebug('폼 제출 완료, 응답 받음');
                    submissionModal.classList.add('hidden');
                    submissionForm.reset();
                    showToast('질문이 성공적으로 등록되었습니다.', 'success');
                    
                    setTimeout(() => {
                        fetchPosts(false);
                        toggleLoading(false);
                    }, 1000);
                } else {
                    logDebug(`폼 제출 실패: ${data.message}`, 'error');
                    showToast(`질문 등록 실패: ${data.message}`, 'error');
                    toggleLoading(false);
                }
            })
            .catch(error => {
                logDebug(`폼 제출 중 오류 발생: ${error.message}`, 'error');
                showToast('질문 등록 중 오류가 발생했습니다. 다시 시도해주세요. ' + error.message, 'error');
                toggleLoading(false);
            });
        });

        // Reset data button
        resetDataBtn.addEventListener('click', () => {
            if (confirm('정말로 모든 데이터를 초기화하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                try {
                    toggleLoading(true);
                    logDebug('데이터 초기화 시작...');
                    
                    const formData = new URLSearchParams();
                    formData.append('action', 'reset');

                    fetch(webAppUrl, {
                        method: 'POST', 
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: formData 
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.text().then(text => { throw new Error(text); });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            logDebug('데이터 초기화 완료', 'success');
                            likedPosts = {};
                            saveLikedPosts();
                            isAdminLoggedIn = false; // 관리자 로그아웃 처리
                            fetchPosts(false); // 목록 새로고침
                            showToast('모든 데이터가 초기화되었습니다.', 'success');
                            adminModal.classList.add('hidden');
                            toggleLoading(false);
                        } else {
                            logDebug(`데이터 초기화 실패: ${data.message}`, 'error');
                            showToast(`데이터 초기화 실패: ${data.message}`, 'error');
                            toggleLoading(false);
                        }
                    })
                    .catch(error => {
                        logDebug(`초기화 중 오류가 발생했습니다: ${error.message}`, 'error');
                        showToast('데이터 초기화 중 오류가 발생했습니다. ' + error.message, 'error');
                        toggleLoading(false);
                    });
                    
                } catch (error) {
                    logDebug(`초기화 중 오류가 발생했습니다: ${error.message}`, 'error');
                    showToast('데이터 초기화 중 오류가 발생했습니다.', 'error');
                    toggleLoading(false);
                }
            }
        });

        // Refresh button click event
        refreshBtn.addEventListener('click', () => {
            logDebug('새로고침 버튼 클릭');
            fetchPosts(false); // 새로고침 아이콘 애니메이션과 함께 데이터 다시 가져오기
        });

        // Add question button click event
        addQuestionBtn.addEventListener('click', () => {
            submissionModal.classList.remove('hidden');
            document.getElementById('name').focus();
        });

        // Close submission modal
        closeSubmissionBtn.addEventListener('click', () => {
            submissionModal.classList.add('hidden');
        });

        // Admin button click event (관리자 모달 띄우기)
        adminBtn.addEventListener('click', () => {
            adminModal.classList.remove('hidden');
            adminPasswordContainer.classList.remove('hidden'); // 비밀번호 입력창 표시
            adminControls.classList.add('hidden'); // 관리자 기능 숨김
            adminPassword.value = '';
            adminPassword.focus();
        });

        // Admin authentication for data reset
        verifyAdminBtn.addEventListener('click', () => {
            const password = adminPassword.value;
            
            if (password === '24003') {
                isAdminLoggedIn = true; // 관리자 로그인 성공
                adminPasswordContainer.classList.add('hidden'); // 비밀번호 입력창 숨김
                adminControls.classList.remove('hidden'); // 관리자 기능 표시
                logDebug('관리자 인증 성공 (데이터 초기화용)');
                if (DEBUG_MODE) {
                    debugBtn.classList.remove('hidden'); 
                }
                fetchPosts(false); // 관리자 로그인 후 게시물 목록 새로고침 (삭제 버튼 표시)
                updateDebugInfo(); // 디버그 정보 업데이트
            } else {
                adminPassword.classList.add('shake');
                showToast('비밀번호가 올바르지 않습니다.', 'error');
                logDebug('관리자 인증 실패: 잘못된 비밀번호', 'error');
                setTimeout(() => {
                    adminPassword.classList.remove('shake');
                }, 500);
            }
        });

        // Close admin modal (관리자 버튼의 '취소' 버튼)
        cancelAdminBtn.addEventListener('click', () => {
            adminModal.classList.add('hidden');
            isAdminLoggedIn = false; // 관리자 로그아웃 처리
            fetchPosts(false); // 관리자 로그아웃 후 게시물 목록 새로고침 (삭제 버튼 숨김)
        });

        // Close admin modal (관리자 인증 완료 후 '닫기' 버튼)
        closeAdminBtn.addEventListener('click', () => {
            adminModal.classList.add('hidden');
            isAdminLoggedIn = false; // 관리자 로그아웃 처리
            fetchPosts(false); // 관리자 로그아웃 후 게시물 목록 새로고침 (삭제 버튼 숨김)
        });


        // Debug button click event
        debugBtn.addEventListener('click', () => {
            updateDebugInfo();
            debugModal.classList.remove('hidden');
        });

        // Close debug modal
        closeDebugBtn.addEventListener('click', () => {
            debugModal.classList.add('hidden');
        });

        closeDebugBtnBottom.addEventListener('click', () => {
            debugModal.classList.add('hidden');
        });

        // Clear debug log
        clearDebugLogBtn.addEventListener('click', () => {
            debugLogs = [];
            debugLogEl.innerHTML = '';
            logDebug('디버그 로그를 지웠습니다.');
        });

        // Enter key for admin password
        adminPassword.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                verifyAdminBtn.click();
            }
        });

        /* ----- View Mode Specific Logic ----- */

        // View Mode Change button click event (비밀번호 모달 없이 바로 선택 모달 띄움)
        viewModeBtn.addEventListener('click', () => {
            viewModeSelectorModal.classList.remove('hidden'); // 보기 방식 선택 모달 바로 표시

            // 현재 저장된 보기 방식에 따라 라디오 버튼 선택
            if (currentViewMode === 'list') {
                radioListView.checked = true;
            } else if (currentViewMode === 'wall') {
                radioWallView.checked = true;
            } else if (currentViewMode === 'timeline') {
                radioTimelineView.checked = true;
            }
        });

        // Save button for View Mode Selector Modal
        saveViewModeBtn.addEventListener('click', () => {
            const selectedMode = document.querySelector('input[name="view-option"]:checked')?.value;
            if (selectedMode) {
                updateGlobalViewMode(selectedMode); // 선택된 모드를 서버에 업데이트
            } else {
                showToast('보기 방식을 선택해주세요.', 'error');
            }
        });

        // Close button for View Mode Selector Modal
        closeViewModeSelectorBtn.addEventListener('click', () => {
            viewModeSelectorModal.classList.add('hidden');
        });

        /* ----- Common Modal Close Logic ----- */
        // Close modals when clicking outside
        adminModal.addEventListener('click', (e) => {
            if (e.target === adminModal) {
                adminModal.classList.add('hidden');
                // 관리자 모달 외부 클릭 시 관리자 권한 초기화
                isAdminLoggedIn = false; 
                fetchPosts(false); 
            }
        });

        submissionModal.addEventListener('click', (e) => {
            if (e.target === submissionModal) {
                submissionModal.classList.add('hidden');
            }
        });

        debugModal.addEventListener('click', (e) => {
            if (e.target === debugModal) {
                debugModal.classList.add('hidden');
            }
        });
        
        viewModeSelectorModal.addEventListener('click', (e) => {
            if (e.target === viewModeSelectorModal) {
                viewModeSelectorModal.classList.add('hidden');
            }
        });


        // On page load, load liked status, view mode and fetch data
        document.addEventListener('DOMContentLoaded', () => {
            logDebug('페이지 로드 완료');
            displayCurrentDate();
            loadLikedPosts();
            // 페이지 로드 시 fetchPosts에서 서버로부터 전역 보기 방식을 받아와 적용
            fetchPosts(true, true); 
        });

        // Auto refresh (every 1 minute)
        setInterval(() => {
            logDebug('자동 새로고침 실행');
            fetchPosts(false);
        }, 60000);
    </script>
</body>
</html>
